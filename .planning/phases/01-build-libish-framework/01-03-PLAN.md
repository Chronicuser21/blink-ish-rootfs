---
phase: 01-build-libish-framework
plan: 03
type: execute
wave: 2
depends_on:
  - "01"
  - "02"
files_modified:
  - /Users/b/ish-ios/libiSH.xcodeproj/project.pbxproj
  - /Users/b/ish-ios/libiSH/libiSH.m
  - /Users/b/ish-ios/README-framework.md
autonomous: true
requirements: []
must_haves:
  truths:
    - "Framework links all three static libraries successfully"
    - "Framework documentation exists with build instructions"
  artifacts:
    - path: "ish-ios/build-ios/libiSH.framework"
      provides: "Complete framework bundle"
      contains: "libiSH"
    - path: "ish-ios/libiSH/libiSH.m"
      provides: "Implementation bridging to internal APIs"
      min_lines: 100
  key_links:
    - from: "libiSH.m"
      to: "kernel/init.h"
      via: "#include"
      pattern: "mount_root|become_first_process"
    - from: "libiSH.m"
      to: "libish.a"
      via: "link"
      pattern: "static library linking"
---

<objective>
Link static libraries into the framework, implement the public API bridge, and create documentation.

Purpose: Complete the framework by connecting the public API to the internal implementation.
Output: Complete libiSH.framework with documentation
</objective>

<execution_context>
@/Users/b/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/b/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-build-libish-framework/01-RESEARCH.md

# Prior plan outputs
@.planning/phases/01-build-libish-framework/01-01-SUMMARY.md
@.planning/phases/01-build-libish-framework/01-02-SUMMARY.md

# Key source files
@/Users/b/ish-ios/kernel/init.h
@/Users/b/ish-ios/fs/tty.h
@/Users/b/ish-ios/kernel/calls.h
</context>

<tasks>

<task type="auto">
  <name>Implement public API bridge to internal functions</name>
  <files>/Users/b/ish-ios/libiSH/libiSH.m</files>
  <action>
Create the implementation file that bridges the public API to iSH's internal functions.

Create `/Users/b/ish-ios/libiSH/libiSH.m`:
```objc
// libiSH.m - Implementation of public API
#import "libiSH.h"
#import "kernel/init.h"
#import "fs/tty.h"
#import "kernel/calls.h"
#import "fs/fake.h"
#import <pthread.h>

// Internal state
static bool g_initialized = false;
static pthread_mutex_t g_init_lock = PTHREAD_MUTEX_INITIALIZER;

int iSHInitialize(void) {
    pthread_mutex_lock(&g_init_lock);
    if (g_initialized) {
        pthread_mutex_unlock(&g_init_lock);
        return 0;  // Already initialized
    }
    
    // Initialize emulator state
    // The actual initialization happens when we mount root and become first process
    g_initialized = true;
    pthread_mutex_unlock(&g_init_lock);
    return 0;
}

int iSHMountRoot(const char *path) {
    if (!g_initialized) {
        return -1;  // Not initialized
    }
    
    // Use fakefs for the root filesystem
    extern const struct fs_ops fakefs;
    int err = mount_root(&fakefs, path);
    return err;
}

int iSHBecomeFirstProcess(void) {
    if (!g_initialized) {
        return -1;
    }
    
    int err = become_first_process();
    return err;
}

// PTY implementation
struct iSHPTY {
    struct tty *tty;
    struct tty_driver driver;
    int master_fd;
    int slave_fd;
};

iSHPTYRef iSHPTYCreate(void) {
    struct iSHPTY *pty = calloc(1, sizeof(struct iSHPTY));
    if (!pty) return NULL;
    
    // Create a fake PTY using iSH's PTY system
    pty->tty = pty_open_fake(&pty->driver);
    if (!pty->tty) {
        free(pty);
        return NULL;
    }
    
    return pty;
}

ssize_t iSHPTYWriteInput(iSHPTYRef pty, const void *data, size_t len) {
    if (!pty || !pty->tty) return -1;
    return tty_input(pty->tty, data, len, false);
}

ssize_t iSHPTYReadOutput(iSHPTYRef pty, void *buf, size_t len) {
    if (!pty || !pty->tty) return -1;
    // Output reading requires connecting to the TTY's output buffer
    // This is a simplified implementation - full version needs fd-based reading
    return -1;  // TODO: Implement proper output reading
}

void iSHPTYSetSize(iSHPTYRef pty, int cols, int rows) {
    if (!pty || !pty->tty) return;
    struct winsize_ ws = {
        .row = rows,
        .col = cols,
        .xpixel = 0,
        .ypixel = 0
    };
    tty_set_winsize(pty->tty, ws);
}

void iSHPTYDestroy(iSHPTYRef pty) {
    if (!pty) return;
    if (pty->tty) {
        tty_hangup(pty->tty);
    }
    free(pty);
}

int iSHExecute(const char *path, char *const argv[], char *const envp[]) {
    if (!g_initialized) return -1;
    
    // Convert to iSH's internal format and execute
    // This requires do_execve from kernel/exec.c
    extern int do_execve(const char *path, int argc, char *const argv[], char *const envp[]);
    
    int argc = 0;
    while (argv[argc]) argc++;
    
    return do_execve(path, argc, argv, envp);
}
```

Note: This is a simplified implementation. The actual integration may need adjustments based on iSH's internal API requirements.
  </action>
  <verify>
    - `test -f /Users/b/ish-ios/libiSH/libiSH.m` returns true
    - `grep -c "mount_root\|become_first_process\|pty_open_fake" /Users/b/ish-ios/libiSH/libiSH.m` returns 3 or more
  </verify>
  <done>Implementation file exists and bridges public API to internal functions</done>
</task>

<task type="auto">
  <name>Configure Xcode to link static libraries</name>
  <files>/Users/b/ish-ios/libiSH.xcodeproj/project.pbxproj</files>
  <action>
Update the Xcode project to:
1. Add libiSH.m to the framework target
2. Link the three static libraries from build-ios/
3. Add required include paths
4. Add required frameworks (SQLite, etc.)

This can be done by editing project.pbxproj directly or using xcodebuild commands.

Key configuration:
- Add source file: libiSH/libiSH.m
- Link libraries: build-ios/libish.a, build-ios/libish_emu.a, build-ios/libfakefs.a
- Header search paths: ., kernel, fs, emu, asbestos
- Link frameworks: libsqlite3.tbd
- Other linker flags: -ObjC (to load all categories)

Create a build phase script to ensure static libs are built:
```bash
# In Build Phases, add Run Script before Compile Sources:
if [ ! -f "${SRCROOT}/build-ios/libish.a" ]; then
    "${SRCROOT}/scripts/build-ios-framework.sh"
fi
```

Or manually verify with xcodebuild:
```bash
xcodebuild -project libiSH.xcodeproj -target libiSH \
    -configuration Release \
    -sdk iphoneos \
    ARCHS=arm64 \
    OTHER_LDFLAGS="-ObjC" \
    LIBRARY_SEARCH_PATHS="${SRCROOT}/build-ios" \
    build
```
  </action>
  <verify>
    - `xcodebuild -project /Users/b/ish-ios/libiSH.xcodeproj -target libiSH -showBuildSettings | grep -c "libish.a\|libish_emu.a\|libfakefs.a"` returns 3 or more
  </verify>
  <done>Xcode project configured to link static libraries</done>
</task>

<task type="auto">
  <name>Create framework documentation</name>
  <files>/Users/b/ish-ios/README-framework.md</files>
  <action>
Create documentation for building and using the framework.

Create `/Users/b/ish-ios/README-framework.md`:
```markdown
# libiSH Framework

A static framework packaging iSH's x86 Linux emulator for iOS.

## Overview

libiSH.framework provides:
- x86 instruction emulation (libish_emu.a)
- Linux syscall translation (libish.a)
- SQLite-backed filesystem (libfakefs.a)

## Building

### Prerequisites

```bash
brew install meson ninja sqlite
pip3 install meson
```

### Build Steps

1. Build static libraries for iOS:
```bash
./scripts/build-ios-framework.sh
```

2. Build framework in Xcode:
```bash
xcodebuild -project libiSH.xcodeproj -target libiSH -configuration Release -sdk iphoneos build
```

### Output

Framework is built to: `build/Release-iphoneos/libiSH.framework/`

## Usage

### Initialization

```objc
#import <libiSH/libiSH.h>

// Initialize once at app launch
iSHInitialize();

// Mount root filesystem
iSHMountRoot("/path/to/rootfs.tar");

// Become first process
iSHBecomeFirstProcess();
```

### Terminal I/O

```objc
// Create PTY
iSHPTYRef pty = iSHPTYCreate();

// Set terminal size
iSHPTYSetSize(pty, 80, 24);

// Write input from user
iSHPTYWriteInput(pty, "ls\n", 3);

// Execute command
iSHExecute("/bin/sh", (char*[]){"sh", NULL}, NULL);
```

## Integration with Blink

libiSH.framework is designed to integrate with Blink Shell's session architecture:

1. Add framework to Blink.xcodeproj
2. Create iSHSession class inheriting from Session
3. Wire PTY I/O to TermDevice/TermStream

See Phase 3 plan for detailed integration steps.

## Architecture

```
libiSH.framework
├── libiSH (binary)
├── Headers/
│   ├── libiSH.h      # Public API
│   └── iSHTypes.h    # Type definitions
└── Info.plist
```

The framework links three static libraries:
- libish_emu.a - x86 emulator (asbestos interpreter)
- libish.a - Syscall translator, process management
- libfakefs.a - SQLite-backed fake filesystem

## Limitations

- x86 emulation only (no ARM64)
- iOS sandbox restricts file access
- Some syscalls not implemented
- Performance slower than native

## License

See LICENSE.md for licensing information.
```
  </action>
  <verify>
    - `test -f /Users/b/ish-ios/README-framework.md` returns true
    - `grep -c "iSHInitialize\|iSHMountRoot\|iSHPTYCreate" /Users/b/ish-ios/README-framework.md` returns 3 or more
  </verify>
  <done>Framework documentation exists with build and usage instructions</done>
</task>

</tasks>

<verification>
1. Framework builds successfully for iOS arm64
2. Framework links all three static libraries
3. Framework exports public API symbols
4. Documentation complete
</verification>

<success_criteria>
- [ ] libiSH.framework builds in Release configuration
- [ ] Framework contains libiSH binary with arm64 architecture
- [ ] nm shows public symbols (iSHInitialize, etc.)
- [ ] README-framework.md documents build and usage
</success_criteria>

<output>
After completion, create `.planning/phases/01-build-libish-framework/01-03-SUMMARY.md`
</output>
